/* APPROACH : To trace memory referencing and dereferencing function dict_ref() and dict_unref(). Increasing the value of count in array, named count by +1 every time when dict_ref gets probed and decreasing it by -1 when dict_unref gets probed. After few mintues, say 15 minutes, calculating the value of counter for each ptr and printing all the traces corresponding to those ptrs whose sum of counter is non zero.

EXPECTED OUTPUT : Traces of functions which are leaking.

SCRIPT'S OUTPUT : Traces of all the functions which are utilizing the pointer which is leaking.

BLOCKER : There can be thousand of traces corresponding to one ptr when count is non-zero. So we need to analyze all of them to find out the possible leak, so it is not a feasible approach beacuse analyzing those outputs will some considerable time.
*/

global count
global arr_ptr
global sum
global ptr
global status
global i
global traces

probe begin {
    warn("Start tracing. Wait for 1 min to complete.\n")
}

function print_trace(){
//counting the no. of occurence for each ptr and storing the count in <sum> array.
		foreach(q in arr_ptr){
			foreach([m,n] in count){
				if(q==m){
				      sum[q] = sum[q] + count[m,n]
				}
			}
		}

//printing all the traces for each ptr if sum of count is non-zero.
	foreach(m in sum){
		if(sum[m]!=0){
			status = 1
			printf("\nptr = %x\n\n",m)
			foreach([s,t] in traces){
				if(m == s){
//					printf("sum = %d\n",sum[m])
						printf("%s\n\n",traces[s,t])
				}
			}printf("      ---     \n")
		}
		
	}
	delete sum
	if(status == 0)
		printf("\nno leaks\n")
	status = 0
}



probe
process("/usr/local/sbin/glusterfs").library("/usr/local/lib/libglusterfs.so.0").function("dict_ref") {
	if (pid() == target()) {
			ptr = $this
			bt1 = ubacktrace()
			count[ptr,bt1] += 1 // to keep count of no. of times dict_ref is probed.
			traces[ptr,bt1] = sprint_ubacktrace() // to store traces each time dict_ref is probed
			arr_ptr[ptr] = 1 //to maintain an array of unique pointers
//			printf("\nref probed : \n");printf("ptr = %x\n",ptr);
//				print_ustack(bt1);printf("count = %d\n",count[ptr,bt1])
	} else{
		printf("target pid didn't matched\n")
	}
}


probe 
process("/usr/local/sbin/glusterfs").library("/usr/local/lib/libglusterfs.so.0").function("dict_unref") {
	if (pid() == target()) {
			ptr = $this
			bt1 = ubacktrace()
			if(arr_ptr[ptr] == 1){
				count[ptr,bt1] -= 1
			        traces[ptr,bt1] = sprint_ubacktrace()
			}
//			printf("\nunref probed : \n");printf("ptr = %x\n",ptr);
//				print_ustack(bt1);printf("count = %d\n",count[ptr,bt1])
	} else{
		printf("target pid didn't matched\n")
	}
}

probe timer.s(30) {
    printf("\n");
    printf("------------------------------------\n")
    printf("ROUND %d\n\n",i)
    i = i + 1
    print_trace()
    printf("------------------------------------\n")
}

